---
title: "Analysis"
author: "Freddie J. Heather"
date: "`r Sys.Date()`"
output: html_document
---

# Set-up

## Required packages

```{r packages}

if (!require("pacman")) install.packages("pacman")

pacman::p_load(
  "tidyverse",
  "arrow",
  "rstan",
  # "tidybayes", 
  "cowplot",
  # "rlang",
  "posterior",
  # "fitdistrplus", 
  "patchwork",
  "scales",
  # "magick",
  "ggsci",
  "lmerTest",
  "remotes"
)
if(!"MuMIn" %in% installed.packages()){
  remotes::install_version("MuMIn", "1.46.0") # this package requires R4.2.0, but that would crash RStan
}
library("MuMIn")

rstan_options(auto_write = TRUE) # avoid recompilation of stan files

select <- dplyr::select
`%!in%` <- Negate(`%in%`)

# rerun part of the analysis?
rerun_msfigures  <- TRUE
rerun_models     <- FALSE # many hours
rerun_visfigures <- FALSE
rerun_tables <- TRUE

```

## Settings

```{r}

rls_min_bins  <- 4
rls_min_count <- 200
cbf_min_count <- 10

```


## Size bins

```{r}

rls_bin <- function(size) {
  
  rls_bin_breaks <- 
    c(2.5, 5.0, 7.5,  10.0, 12.5, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0, 
      50.0, 62.5, 75.0, 87.5, 100.0, 112.5, 125.0, 137.5, 150.0, 
      162.5, 175.0, 187.5, 200.0, 250.0, 300.0, 350.0, 400.0)
  
  rls_bin_table <-
    tibble(size_class = c(0, rls_bin_breaks, 500)) %>% 
    mutate(
      size_indx  = 0:(length(size_class)-1),
      size_min = (size_class + lag(size_class))/2,
      size_max = lead(size_min)
    ) %>% 
    filter(size_class %in% c(rls_bin_breaks, 500))
  
  rls_bin_table$size_class[.bincode(size, breaks = c(0, rls_bin_table$size_max))]
}

```

## Wrangling functions

```{r}

# outputs clean body size bin table given a vector of body sizes
get_bintable <- function(size_vector){
  
  sizebins <- 
    size_vector %>% 
    unique() %>% 
    c(0) %>%
    sort()
  
  tibble(size_class = sizebins) %>% 
    mutate(size_indx = 0:(nrow(.)-1),
           size_min = (size_class + lag(size_class))/2,
           size_max = lead(size_min)) %>% 
    filter(size_class != 0) %>% 
    mutate(size_max = case_when(size_class == max(sizebins) ~ size_class + (size_class-size_min), 
                                TRUE ~ size_max))
}

# takes population number, size_class, and n, outputs clean table with population id
clean_data <- function(count_table, 
                       sizes = "size_class", 
                       count = "n"){
  
  sizebin_tbl <- 
    count_table %>% 
    pull(!!sizes) %>% 
    get_bintable()
  
  popln_tbl <- 
    count_table %>% 
    select(population) %>% 
    distinct() %>% 
    mutate(population_indx = row_number())
  
  count_table %>% 
    rename(size_class := !!sizes) %>% 
    left_join(popln_tbl, by = join_by(population)) %>% 
    left_join(sizebin_tbl, by = join_by(size_class)) %>% 
    add_count(population_indx, wt = n, name = "population_n") %>% 
    arrange(population_indx, size_indx) %>%
    mutate(p = n/population_n) %>% 
    mutate(row = 1:n()) %>% 
    mutate(min_row = min(row), 
           max_row = max(row),
           .by = population_indx) 
  
}

```


# Data import/wrangling

## Import RLS

```{r}

obsdata_filename <- function(datasource, population_level){
  paste0("input/data/cleaned/", datasource, "_obsdata_", 
         population_level, "_", 
         {if(datasource == "rls") paste0(rls_min_bins,  "_") else NULL},
         get(paste0(datasource, "_min_count")), ".csv")
}


# Info on fishing pressure -----------------------------------------------------

# https://www.fish.gov.au/reports/species
frdc <- read_csv("input/data_cleaning/frdc_fished.csv", 
                 show_col_types = FALSE) 
targeted <- 
  read_csv("input/data_cleaning/fishing_intensity.csv", 
           show_col_types = FALSE) %>% 
  filter(fishing_intensity > 1)

# ------------------------------------------------------------------------------

for(pop in c("species", "ecoregion", "gridcell")){
  
  raw <- 
    read_parquet("input/data/raw/data_obs_cleaned.parquet") %>% 
    left_join(read_parquet("input/data/raw/survey_list_m1_aus.parquet"), 
              by = join_by(survey_id)) %>% 
    rename(species = species_name) %>% 
    mutate(lat_grid = round(latitude), 
           lon_grid = round(longitude), 
           gridcell = paste(lat_grid, lon_grid, sep = "_"), 
           population = paste(species, !!sym(pop), sep = "__")) 
  
  
  n_transects <- 
    raw %>% 
    select(population, survey_date) %>% 
    distinct() %>% 
    count(population, name = "n_transects")
  
  
  raw %>% 
    count(population, species, size_class, wt = n) %>% 
    add_count(population, name = "n_sizebins") %>% 
    add_count(population, wt = n, name = "population_n") %>%
    filter(n_sizebins >= rls_min_bins,
           population_n >= rls_min_count) %>%
    arrange(desc(population_n)) %>% 
    clean_data() %>% 
    mutate(species = str_extract(population, ".*(?=__)")) %>% 
    mutate(genus = str_extract(species, ".*(?=\\s)")) %>% 
    mutate(fished = case_when((species %!in% frdc$species)&
                                (genus %!in% frdc$genus)&
                                (species %!in% targeted$species) ~ FALSE,
                              TRUE ~ TRUE)) %>%
    left_join(n_transects, by = join_by(population)) %>% 
    assign(paste0("obsdata_rls_", pop), value = ., envir = .GlobalEnv)
  
  write_csv(get(paste0("obsdata_rls_", pop)), obsdata_filename("rls", pop))
  
  assign(
    paste0("rls_npops_", pop),
    get(paste0("obsdata_rls_", pop)) %>% 
      pull(population) %>%
      n_distinct()
  )
  
  rm(pop)
}

```

## Import CBF

```{r}

for(pop in c("species", "location")){
  
  if(!file.exists(obsdata_filename("cbf", pop))){
    
    read_csv("input/data/raw/cbf_raw.csv", 
             show_col_types = FALSE) %>%
      mutate(sl_cm = SL/10,
             tl_cm = TL/10) %>% # now in cm, not mm
      select(location = Location,
             species = sciname,
             tl_cm
      ) %>%
      mutate(size_class = tl_cm %>% round(1), 
             size_min = size_class - 0.05, 
             size_max = size_class + 0.05) %>% 
      filter(str_detect(species, "^[A-Z]{1}[a-z]+\\s[a-z]+$")) %>% 
      mutate(genus = str_extract(species, ".*(?=\\s)")) %>% 
      mutate(fished = (species %in% frdc$species)| 
               (genus %in% frdc$genus)|
               (species %in% targeted$species)) %>% 
      mutate(population = paste(species, !!sym(pop), sep = "__")) %>% 
      count(population, species, size_class, size_min, size_max) %>% 
      add_count(population, wt = n,  name = "population_n") %>%
      filter(population_n >= cbf_min_count) %>%
      arrange(desc(population_n)) %>% 
      assign(paste0("obsdata_cbf_", pop), value = ., envir = .GlobalEnv)
    
    write_csv(get(paste0("obsdata_cbf_", pop)), obsdata_filename("cbf", pop))
    
  } else {
    read_csv(obsdata_filename("cbf", pop), show_col_types = FALSE) %>% 
      assign(paste0("obsdata_cbf_", pop), value = ., envir = .GlobalEnv)
  }
  
  assign(
    paste0("cbf_npops_", pop),
    get(paste0("obsdata_cbf_", pop)) %>% 
      pull(population) %>%
      n_distinct()
  )
  
  rm(pop)
}

```

## Mean sizes

```{r}

for(pop in c("species", "ecoregion", "gridcell")){
  
  cbf_pop <- ifelse(pop %in% c("ecoregion", "gridcell"), "location", pop)
  
  get(paste0("obsdata_rls_", pop)) %>% 
    select(population, size_class, n) %>% 
    uncount(n) %>% 
    summarise(mean_size = mean(size_class),
              .by = population) %>%
    mutate(data = "rls") %>% 
    bind_rows(
      get(paste0("obsdata_cbf_", cbf_pop)) %>% 
        uncount(n) %>% 
        summarise(mean_size = mean(size_class),
                  .by = population) %>%  
        mutate(data = "cbf")) %>% 
    mutate(species = str_extract(population, ".*(?=__)")) %>% 
    assign(x = paste0("meansizes_", pop), value = ., envir = .GlobalEnv)
  
  rm(pop, cbf_pop)
}

```

## Fished species

```{r}

fished_species <- 
  tibble(species = c(obsdata_cbf_species$species, obsdata_rls_species$species)) %>% 
  mutate(genus = str_extract(species, ".*(?=\\s)")) %>% 
  filter((species %in% frdc$species)| 
           (genus %in% frdc$genus)|
           (species %in% targeted$species)) %>% 
  pull(species) %>% 
  unique()

rm(frdc, targeted)

```



# Data visualisation

## Empirical distributions

```{r}

for(src in c("rls", "cbf")){
  for(pop in c("species", "ecoregion", "gridcell")){
    
    if(src == "cbf" & pop == "ecoregion") next
    pop <- ifelse(src == "cbf" & pop == "gridcell", "location", pop)
    
    current_obsdata <- 
      get(paste0("obsdata_", src, "_", pop)) %>% 
      arrange(population)
    
    dists <- current_obsdata$population %>% unique()
    plots_per_page <- ifelse(src == "cbf", 50, 100)
    
    for(page in 1:ceiling(length(dists)/plots_per_page)){
      
      first_dist <- ((page-1)*plots_per_page)+1
      second_dist <- first_dist + (plots_per_page-1)
      
      if(second_dist > length(dists)) {
        second_dist <- length(dists)
      }
      
      if(!file.exists(paste0("output/empirical_dists/", src, "/",  pop, "/", first_dist, "_", second_dist, ".png")) | rerun_visfigures){
        
        p <- 
          current_obsdata %>% 
          filter(population %in% dists[first_dist:second_dist]) %>% 
          ggplot() +
          aes(
            x = size_class, 
            y = n
          ) +
          geom_point() +
          geom_path() +
          facet_wrap(~population, scales = "free") +
          scale_y_continuous(labels = scales::label_number(scale_cut = cut_short_scale()))
        
        ggsave(paste0("output/empirical_dists/", src, "/", pop, "/", first_dist, "_", second_dist, ".png"), 
               p, 
               height = 15, 
               width = 25)
        rm(p)
      }
    }
    rm(current_obsdata)
  }
}

```


## Biomdal distributions

Using visual inspection of the body size distributions, the following were regarded as 'bimodal'.

```{r}

for(src in c("rls", "cbf")){
  for(pop in c("species", "ecoregion", "gridcell")){
    
    if(src == "cbf" & pop == "ecoregion") next
    pop <- ifelse(src == "cbf" & pop == "gridcell", "location", pop)
    
    read_csv(file = paste0("input/data_cleaning/bimodal_", src, "_", pop, ".csv"), 
             show_col_types = FALSE) %>% 
      pull(population) %>% 
      assign(paste0("bimodal_pops_", src, "_", pop), value = ., envir = .GlobalEnv)
    
    if(!file.exists(paste0("output/empirical_dists/bimodal/", src, "_", pop, ".png")) | rerun_visfigures){
      
      p <- 
        get(paste0("obsdata_", src, "_", pop)) %>% 
        filter(population %in% get(paste0("bimodal_pops_", src, "_", pop))) %>% 
        ggplot() +
        aes(
          x = size_class, 
          y = n
        ) +
        geom_point() +
        geom_path() +
        facet_wrap(~population, scales = "free") +
        theme_cowplot() +
        scale_y_continuous(labels = scales::label_number(scale_cut = cut_short_scale()))
      
      ggsave(filename = paste0("output/empirical_dists/bimodal/", src, "_", pop, ".png"), 
             plot = p, 
             height = 15, 
             width = 25)
      
      rm(p)
    }
    rm(pop)
  }
  rm(src)
}


```


# Modelling

## Functions

```{r}

mod_out_filename <- function(datasource, population_level, modelname, output_type){
  paste0("output/model_fits/", 
         datasource, "_", 
         output_type, "_", 
         modelname, "_", 
         population_level, 
         {if(datasource == "rls" & output_type == "pars"){
           ".parquet"
         } else {
           ".csv"
         }})
}

# Removing the estimates of models that did not converge
nonconverge_pops <- function(src, mod, pop){
  
  errors <- 
    if(file.exists(mod_out_filename(src, pop, mod, "errors"))){
      read_csv(mod_out_filename(src, pop, mod, "errors"), show_col_types = FALSE) %>% 
        pull(population) %>% 
        unique()
      
    } else {
      c()
    }
  
  issues <- 
    if(file.exists(mod_out_filename("rls", pop, mod, "convergence"))){
      read_csv(mod_out_filename("rls", pop, mod, "convergence"), show_col_types = FALSE) %>% 
        filter(rhat > 1.1) %>% 
        pull(population) %>% 
        unique()
      
    } else {
      c()
    }
  
  c(errors, issues) %>% unique()
  
}


```


## Model fit

```{r}

for(src in c("rls", "cbf")){
  for(pop in c("species", "ecoregion", "gridcell")){
    for(mod in c("lognormal", "normal")){
      
      if(src == "cbf" & pop == "ecoregion") next
      pop <- ifelse(src == "cbf" & pop == "gridcell", "location", pop)
      
      model_pars <- 
        if(!file.exists(mod_out_filename(src, pop, mod, "pars")) | rerun_models){
          tibble(population = character())
        } else {
          
          if(src == "cbf"){
            mod_out_filename(src, pop, mod, "pars") %>% 
              read_csv(show_col_types = FALSE)
          } else {
            mod_out_filename(src, pop, mod, "pars") %>% 
              read_parquet()
          }
        }
      
      model_convergence <- 
        if(!file.exists(mod_out_filename(src, pop, mod, "convergence")) | rerun_models){
          tibble(population = character())
        } else {
          mod_out_filename(src, pop, mod, "convergence") %>% 
            read_csv(show_col_types = FALSE)
        }
      
      model_errors <- 
        if(!file.exists(mod_out_filename(src, pop, mod, "errors")) | rerun_models){
          tibble(population = character())
        } else {
          mod_out_filename(src, pop, mod, "errors") %>% 
            read_csv(show_col_types = FALSE)
        }
      
      npops_done <- 
        model_pars %>% 
        drop_na() %>% 
        pull(population) %>% 
        c(model_errors$population) %>% 
        unique() %>% 
        length()
      
      if((npops_done) < get(paste0(src, "_npops_", pop))){
        
        for(i in 1:get(paste0(src, "_npops_", pop))){
          
          current_data <-
            get(paste0("obsdata_", src, "_", pop)) %>% 
            filter(population_indx == i) 
          
          current_pop <- 
            current_data %>% 
            pull(population) %>% 
            unique()
          
          if(!(current_pop %in% c(model_pars$population, 
                                  model_errors$population))){
            
            
            inits <-
              current_data %>% 
              uncount(n) %>% 
              summarise(mu = mean(size_class), 
                        sigma = sd(size_class),
                        meanlog = mean(log(size_class)), 
                        sdlog = sd(log(size_class)))
            
            stan_data <- 
              list(
                B = length(unique(current_data$size_indx)),
                b_upr = current_data$size_max,
                b_lwr = current_data$size_min,
                n = current_data$n
              )
            
            if(mod == "normal"){
              # inits to prevent log(0) probability errors with the normal dist
              fit <- 
                stan(file = paste0("input/stan_models/", mod, ".stan"),
                     data = stan_data,
                     iter = 10000,
                     warmup = 5000,
                     chains = 3,
                     refresh = 5000,
                     cores = 1, 
                     init = list(list(mu = inits$mu, sigma = inits$sigma),
                                 list(mu = inits$mu, sigma = inits$sigma),
                                 list(mu = inits$mu, sigma = inits$sigma)))
            } else {
              
              fit <- 
                stan(file = paste0("input/stan_models/", mod, ".stan"),
                     data = stan_data,
                     iter = 10000,
                     warmup = 5000,
                     chains = 3,
                     refresh = 5000,
                     cores = 1)
            }
            
            
            rm(inits, stan_data)
            
            if(!is.null(summary(fit)$summary)){
              
              rhat <- 
                summary(fit)$summary[,"Rhat"] %>% 
                as_tibble(rownames = "pars") %>% 
                mutate(population = unique(current_data$population)) %>% 
                rename(rhat = value)
              
              n_eff <- 
                summary(fit)$summary[,"n_eff"]%>% 
                as_tibble(rownames = "pars") %>% 
                mutate(population = unique(current_data$population)) %>% 
                rename(n_eff = value)
              
              rls_model_convergence <- 
                bind_rows(
                  rls_model_convergence,
                  left_join(rhat, n_eff, 
                            by = join_by(pars, population)))
              
              rm(rhat, n_eff)
              
              current_pars <-
                fit %>% 
                as_draws_df() %>% 
                as_tibble() %>% 
                mutate(population = current_pop)
              
              rm(current_pop)
              
              model_pars <- 
                bind_rows(
                  model_pars,
                  current_pars
                )
              cat(paste(i, "done."))
              
            } else  {
              
              model_errors <- 
                bind_rows(
                  model_errors, 
                  tibble(population = unique(current_data$population))
                )
              
            }
            
          } else {
            cat(paste(src, "population", i, "at the", pop, "level already done.\n"))
          }
          
          rm(current_data)
        }
        rm(i)
      } else {
        cat(paste("All", get(paste0(src, "_npops_", pop)), ifelse(src == "rls", "RLS", "CBF"), pop, "populations have already run for", mod, "\n"))
      }
      
      rm(mod)
    }
    rm(pop)
  }
  rm(src)
}

```

## Model summary

```{r}

for(pop in c("species", "ecoregion", "gridcell")){
  for(src in c("rls", "cbf")){
    
    if(src == "cbf" & pop == "ecoregion") next
    pop <- ifelse(src == "cbf" & pop == "gridcell", "location", pop)
    
    paste0("output/model_fits/", src, "_pars_lognormal_", pop, ifelse(src == "rls", ".parquet", ".csv")) %>% 
      {if(src == "rls") read_parquet(.) else read_csv(., show_col_types = FALSE)} %>%
      drop_na() %>% 
      summarise(
        meanlog = median(meanlog), 
        sdlog = median(sdlog), 
        lp_lognormal = median(lp__),
        .by = population
      ) %>% 
      mutate(data = src) %>% 
      filter(!(population %in% nonconverge_pops(src, "lognormal", pop) )) %>% 
      assign(x = paste0(src, "_pars_lognormal_", pop), value = ., envir = .GlobalEnv)
    
    paste0("output/model_fits/", src, "_pars_normal_", pop, ifelse(src == "rls", ".parquet", ".csv")) %>% 
      {if(src == "rls") read_parquet(.) else read_csv(., show_col_types = FALSE)} %>%
      drop_na() %>% 
      summarise(
        mu = mean(mu), 
        sigma = median(sigma), 
        lp_normal = median(lp__),
        .by = population
      ) %>% 
      mutate(data = src) %>% 
      filter(!(population %in% nonconverge_pops(src, "normal", pop) )) %>% 
      assign(x = paste0(src, "_pars_normal_", pop), value = ., envir = .GlobalEnv)
    
    rm(src)
  }
  rm(pop)
}

for(pop in c("species", "ecoregion", "gridcell")){
  cbf_pop <- ifelse(pop %in% c("ecoregion", "gridcell"), "location", pop)
  
  get(paste0("obsdata_rls_", pop)) %>% 
    select(population, size_class, n) %>% 
    mutate(data = "rls") %>% 
    uncount(n) %>% 
    summarise(mean_size = mean(size_class),
              .by = c(population, data)) %>% 
    bind_rows(
      get(paste0("obsdata_cbf_", cbf_pop)) %>% 
        mutate(data = "cbf") %>% 
        uncount(n) %>% 
        summarise(mean_size = mean(size_class),
                  .by = c(population, data))
    ) %>% 
    assign(x = paste0("meansizes_", pop), value = ., envir = .GlobalEnv)
  
  bind_rows(
    full_join(
      get(paste0("rls_pars_normal_", pop)),
      get(paste0("rls_pars_lognormal_", pop)),
      by = join_by(population, data)
    ) %>% 
      mutate(ll_diff = lp_normal - lp_lognormal) %>% 
      mutate(normal_better = lp_normal>lp_lognormal), 
    full_join(
      get(paste0("cbf_pars_normal_", cbf_pop)),
      get(paste0("cbf_pars_lognormal_", cbf_pop)),
      by = join_by(population, data)
    ) %>% 
      mutate(ll_diff = lp_normal - lp_lognormal) %>% 
      mutate(normal_better = lp_normal>lp_lognormal)
  ) %>% 
    mutate(
      normal_better = case_when(
        is.na(mu) ~ FALSE, 
        is.na(meanlog) ~ TRUE, 
        TRUE ~ normal_better), 
      cov_normal = sigma/mu,
      cov_lognormal = sqrt(exp(sdlog^2)-1), 
      cov_pref = case_when(normal_better ~ cov_normal, 
                           TRUE ~ cov_lognormal),
      better_dist = ifelse(normal_better, "normal", "lognormal"), 
      lognormal_mean = exp(meanlog  + ((sdlog^2)/2))
    ) %>% 
    left_join(get(paste0("meansizes_", pop)),
              by = join_by(population, data)) %>% 
    mutate(lowmean = (data == "rls" & mu < 2.5)|(data == "rls" & lognormal_mean < 2.5) |(data == "cbf" & mu < 0)|(data == "cbf" & lognormal_mean < 0)) %>% 
    # filter(!lowmean) %>%
    mutate(species = str_extract(population, ".*(?=__)")) %>% 
    mutate(fished = species %in% fished_species) %>% 
    mutate(bimodal = population %in% c(get(paste0("bimodal_pops_rls_", pop)), get(paste0("bimodal_pops_cbf_", cbf_pop)))) %>% 
    assign(x = paste0("plotdata_", pop), value = ., envir = .GlobalEnv)
}

```

# Figures

## Scaling body size

```{r}

if(!file.exists( paste0("manuscript/ms_figures/comparing_distributions.png"))| rerun_msfigures){
  
  rls_sample_populations <- 
    obsdata_rls_gridcell %>% 
    filter(population_indx < 10)
  
  p_scaling_size_1 <- 
    rls_sample_populations %>% 
    left_join(meansizes_gridcell, by = join_by(population)) %>% 
    mutate(scaled_size = size_class/mean_size) %>% 
    mutate(scaled_n = n/population_n) %>%
    ggplot(aes(x = size_class, y = n, color = population)) +
    scale_color_simpsons() +
    scale_x_continuous(labels = label_number(suffix="cm")) +
    geom_line(aes(y = n)) +
    theme(legend.position = "none") +
    theme_cowplot(20) +
    labs(
      x = "Body size",
      y = "N"
    ) +
    theme(legend.position = "none")
  
  p_scaling_size_2 <- 
    rls_sample_populations %>% 
    left_join(meansizes_gridcell, by = join_by(population)) %>% 
    mutate(scaled_size = size_class/mean_size) %>% 
    mutate(scaled_n = n/population_n) %>%
    ggplot(aes(x = size_class, y = scaled_n, col = population)) +
    geom_line(aes(y = scaled_n)) +
    scale_color_simpsons() +
    scale_x_continuous(labels = label_number(suffix="cm")) +
    theme(legend.position = "none") +
    theme_cowplot(20) +
    labs(
      x = "Body size",
      y = "Relative N"
    ) +
    theme(legend.position = "none")
  
  p_scaling_size_3 <- 
    rls_sample_populations %>% 
    left_join(meansizes_gridcell, by = join_by(population)) %>% 
    mutate(scaled_size = size_class/mean_size) %>% 
    mutate(scaled_n = n/population_n) %>%
    ggplot(aes(x = scaled_size, y = scaled_n, col = population)) +
    geom_line(aes(y = scaled_n)) +
    scale_color_simpsons() +
    scale_x_continuous(label = label_number(suffix = "x")) +
    theme(legend.position = "none") +
    theme_cowplot(20) +
    labs(
      x = "Relative body size",
      y = "Relative N"
    )+
    theme(legend.position = "none")
  
  p_scaling_size_4 <-
    rls_sample_populations %>% 
    left_join(meansizes_gridcell, by = join_by(population)) %>% 
    mutate(scaled_size = size_class/mean_size) %>% 
    mutate(scaled_n = n/population_n) %>%
    ggplot(aes(x = scaled_size, y = scaled_n, col = population)) +
    geom_line(aes(y = scaled_n)) +
    scale_x_log10(label = label_number(suffix = "x")) +
    scale_y_log10() +
    scale_color_simpsons() +
    theme(legend.position = "none") +
    theme_cowplot(20) +
    labs(
      x = "Relative body size (log)",
      y = "Relative N (log)"
    ) +
    theme(legend.position = "none")
  
  all_pars_median <- 
    plotdata_gridcell %>% 
    filter(!lowmean, 
           !bimodal) %>% 
    drop_na() %>% 
    summarise(
      mu = median(mu),
      sigma = median(sigma),
      meanlog = median(meanlog),
      sdlog = median(sdlog)
    ) 
  
  scale_size_vec <- function(size_vector, lower_limit = 1.25) {
    tibble(size = size_vector) %>% 
      filter(size > lower_limit) %>% 
      mutate(size = rls_bin(size)) %>%
      mutate(mean_size = mean(size)) %>% 
      mutate(scaled_size = size/mean_size) %>% 
      count(scaled_size) %>% 
      mutate(scaled_n = n/sum(n)) %>% 
      select(scaled_size, scaled_n)
  }
  
  plot_lines <- 
    scale_size_vec(rnorm(1e6, all_pars_median$mu, all_pars_median$sigma)) %>% 
    mutate(dist = "normal") %>% 
    bind_rows(
      scale_size_vec(rlnorm(1e6, all_pars_median$meanlog, all_pars_median$sdlog)) %>% 
        mutate(dist = "lognormal") 
    )
  
  
  p_scaling_size_5 <- 
    obsdata_rls_gridcell %>% 
    bind_rows(get(paste0("obsdata_cbf_", "location"))) %>% 
    left_join(meansizes_gridcell, by = join_by(population)) %>% 
    left_join(plotdata_gridcell %>% 
                filter(!lowmean) %>% 
                select(population, normal_better), 
              by = join_by(population)) %>% 
    mutate(scaled_size = size_class/mean_size) %>% 
    mutate(scaled_n = n/population_n) %>%
    ggplot(aes(x = scaled_size, y = scaled_n)) +
    geom_line(aes(y = scaled_n, group = population), col = "grey70", alpha = 0.1) +
    geom_line(aes(col = dist), linewidth = 2, data = plot_lines) +
    scale_x_log10(label = label_number(suffix = "x")) +
    scale_y_log10() +
    scale_color_manual(values = c("normal" = rgb(181, 144, 19, maxColorValue=255),
                                  "lognormal" = rgb(29, 84, 128, maxColorValue=255))) +
    theme_cowplot(20) +
    theme(legend.position = c(0.1,0.1), 
          legend.justification = c(0,0),
          legend.title = element_blank()) +
    labs(
      x = "Relative body size (log)",
      y = "Relative abundance (log)"
    )
  
  p_scaling_size_all <- 
    p_scaling_size_1 + 
    p_scaling_size_2 + 
    p_scaling_size_3 + 
    p_scaling_size_4 - 
    p_scaling_size_5 + 
    plot_layout(ncol=1)  + 
    plot_annotation(tag_levels = 'A')
  
  ggsave(filename = paste0("manuscript/ms_figures/comparing_distributions.png"),
         plot = p_scaling_size_all,
         height = 35,
         width = 25,
         units = "cm")
  
  rm(
    rls_sample_populations,
    plot_lines,
    all_pars_median,
    p_scaling_size_1, 
    p_scaling_size_2,
    p_scaling_size_3, 
    p_scaling_size_4, 
    p_scaling_size_5)
  
}

```


## CV-meansize regression

```{r}

if(!file.exists(paste0("manuscript/ms_figures/parameter_regression.png")) | rerun_msfigures){
  for(inc_fished in c(TRUE, FALSE)){
    for(inc_bimodal in c(TRUE, FALSE)){
      for(pop in c("species", "ecoregion", "gridcell")){
        
        plotdata_current <- 
          get(paste0("plotdata_", pop)) %>% 
          filter(!lowmean) %>% 
          {if(inc_fished) . else filter(., !fished)} %>% 
          {if(inc_bimodal) . else filter(., !bimodal)}
        
        q_cov <- function(quant) quantile(plotdata_current$cov_pref, quant)
        
        p1 <- 
          plotdata_current %>% 
          ggplot() + 
          aes(
            x = mean_size, 
            y = cov_pref, 
            pch = data,
            col = better_dist
          ) +
          annotate(geom = "rect",
                   xmin = min(plotdata_current$mean_size), 
                   xmax = max(plotdata_current$mean_size), 
                   ymin = q_cov(0.975),
                   ymax = q_cov(0.025), 
                   fill = "grey90", 
                   col = "transparent") +
          annotate(geom = "rect",
                   xmin = min(plotdata_current$mean_size), 
                   xmax = max(plotdata_current$mean_size), 
                   ymin = q_cov(0.05),
                   ymax = q_cov(0.95), 
                   fill = "grey70", 
                   col = "transparent") +
          annotate(geom = "rect",
                   xmin = min(plotdata_current$mean_size), 
                   xmax = max(plotdata_current$mean_size), 
                   ymin = q_cov(0.1),
                   ymax = q_cov(0.9), 
                   fill = "grey50", 
                   col = "transparent") +
          annotate(geom = "text", 
                   x = 100, y = q_cov(0.9) - ((q_cov(0.9) - q_cov(0.1))/2),
                   label = "80%") +
          annotate(geom = "text", 
                   x = 100, y = q_cov(0.95) - ((q_cov(0.95) - q_cov(0.9))/2), 
                   label = "90%") +
          annotate(geom = "text", 
                   x = 100, y = q_cov(0.975) - ((q_cov(0.975) - q_cov(0.95))/2), 
                   label = "95%") +
          geom_point(alpha = 1) +
          geom_point(col = "red", pch = 4, data = plotdata_current %>% filter(bimodal)) +
          # geom_point(col = "red", pch = 4, data = plotdata_current %>% filter(fished)) +
          scale_x_continuous(trans = "log10", labels = label_number(suffix="cm"), 
                             limits = range(plotdata_current$mean_size)) +
          scale_shape_manual(values = c("rls" = 21, "cbf" = 24), 
                             labels = c("rls" = "Reef Life Survey (binned)",
                                        "cbf" = "Cryptobenthic (continuous)")) +
          scale_color_manual(values = c("normal" = rgb(181, 144, 19, maxColorValue=255),
                                        "lognormal" = rgb(29, 84, 128, maxColorValue=255)),
                             labels = c("normal" = "Normal preferred",
                                        "lognormal" = "Lognormal preferred")) +
          labs(x = "Log mean size", 
               y = "Coefficient of variation") +
          theme_cowplot(20) +
          theme(legend.position = "none")
        
        assign(x = paste("p1", pop, ifelse(inc_fished, "incfished", "unfished"), sep = "_"), value = p1, envir = .GlobalEnv)
        
        p2 <- 
          plotdata_current %>% 
          ggplot() +
          aes(
            x = cov_pref, 
            fill = better_dist
          ) +
          scale_fill_manual(values = c("normal" = rgb(181, 144, 19, maxColorValue=255),
                                       "lognormal" = rgb(29, 84, 128, maxColorValue=255))) +
          geom_density(alpha = 0.3, col = "black") +
          coord_flip() +
          theme_void(20) +
          theme(legend.position = "none") 
        
        
        assign(x = paste("p2", pop, ifelse(inc_fished, "incfished", "unfished"), sep = "_"), value = p2, envir = .GlobalEnv)
        
        ggsave(filename = paste0("output/figs/param_regression/", pop, {if(inc_fished) "_incfished" else "_unfished"}, {if(inc_bimodal) "_incbimodal" else "_nobimodal"}, ".png"),
               plot = p1 + p2 + plot_layout(widths = c(6,1)),
               height = 15,
               width = 15*1.618,
               units = "cm")
        
        rm(p1, p2, pop, q_cov, plotdata_current)
      }
      
      legend_only <- get_legend(
        get(paste0("p1_gridcell_", ifelse(inc_fished, "incfished", "unfished"))) + 
          theme(legend.position = "bottom",
                legend.justification = c(0.5,0.5),
                legend.background = element_rect(color = "black"),
                legend.margin=margin(10,10,10,10),
                legend.title = element_blank()))
      
      plot_ylim <- max(layer_scales(get(paste0("p1_gridcell_", ifelse(inc_fished, "incfished", "unfished"))))$y$range$range,
                       layer_scales(get(paste0("p1_species_", ifelse(inc_fished, "incfished", "unfished"))))$y$range$range)
      
      fig_design <- {"AAAAAABCCCCCCD
      AAAAAABCCCCCCD
      AAAAAABCCCCCCD
      AAAAAABCCCCCCD
      AAAAAABCCCCCCD
      ####EEEEEE####"}
      
      p_cv_meansize <-
        get(paste0("p1_gridcell_", ifelse(inc_fished, "incfished", "unfished"))) + annotate("text", x = 10, y = plot_ylim, label = "Population-level", size = 12) + ylim(0, plot_ylim) +
        get(paste0("p2_gridcell_", ifelse(inc_fished, "incfished", "unfished"))) + xlim(0, plot_ylim) +
        get(paste0("p1_species_", ifelse(inc_fished, "incfished", "unfished"))) + annotate("text", x = 10, y = plot_ylim, label = "Species-level", size = 12) + ylim(0, plot_ylim) + theme(axis.title.y = element_blank()) +
        get(paste0("p2_species_", ifelse(inc_fished, "incfished", "unfished"))) + xlim(0, plot_ylim) + 
        ggpubr::as_ggplot(legend_only) +
        plot_layout(design = fig_design)
      
      ggsave(filename = paste0("manuscript/ms_figures/parameter_regression", {if(inc_fished) "_incfished" else "_unfished"}, {if(inc_bimodal) "_incbimodal" else "_nobimodal"}, ".png"),
             plot = p_cv_meansize,
             height = 15,
             width = 40,
             units = "cm")
      
      rm(inc_bimodal, p_cv_meansize, fig_design, plot_ylim, legend_only)
    }
    rm(inc_fished)
  }
}


```

## Estimated vs predicted size

Estimating body size from mean size

```{r}

for(inc_fished in c(TRUE, FALSE)){
  
  if(!file.exists(paste0("manuscript/ms_figures/variation_explained",  ifelse(inc_fished, "_incfished", "_unfished"), ".png")) | rerun_msfigures){
    
    
    if(!file.exists(paste0("output/tables/var_explained_bycv",  ifelse(inc_fished, "_incfished", "_unfished"), ".csv")) | rerun_models){
      
      d1 <- 
        obsdata_rls_gridcell %>% 
        select(population, size_class, size_min, size_max, n, p)
      
      d2 <- 
        obsdata_cbf_location %>% 
        mutate(p = n/population_n) %>% 
        select(population, size_class, size_min, size_max, n, p)
      
      joined_data <-  
        meansizes_gridcell %>% 
        right_join(bind_rows(d1, d2), 
                   by = join_by(population)) %>% 
        left_join(plotdata_gridcell) %>% 
        filter(!lowmean) %>% 
        filter(!bimodal) %>% 
        {if(inc_fished) . else filter(., !fished)} %>% 
        select(population, species, size_class, mean_size, size_min, size_max, n, p, mu, sigma, meanlog, sdlog, better_dist)
      
      out <- tibble()
      for(c in seq(0, 1.5, by = 0.01)){
        
        estimated_prob <- 
          joined_data %>% 
          mutate(mu = mean_size,
                 sd = mu*c,
                 sdlog = sqrt(log((c^2)+1)),
                 meanlog = log(mean_size) - ((sdlog^2)/2)) %>%
          mutate(p_norm = pnorm(size_max, mean = mu, sd = sd) -  pnorm(size_min, mean = mu, sd = sd),
                 p_lnorm = plnorm(size_max, meanlog = meanlog, sdlog = sdlog) -  plnorm(size_min, meanlog = meanlog, sdlog = sdlog), 
                 p_pref = ifelse(better_dist == "normal", p_norm, p_lnorm)) %>% 
          select(population, species,
                 size_class, better_dist, 
                 p, p_norm, p_lnorm, p_pref)
        
        lmer_norm <- lmerTest::lmer(p ~ p_norm + (1|species), data = estimated_prob) 
        lmer_lnorm <-  lmerTest::lmer(p ~ p_lnorm + (1|species), data = estimated_prob) 
        lmer_pref <-  lmerTest::lmer(p ~ p_pref + (1|species), data = estimated_prob) 
        
        out <- 
          out %>% 
          bind_rows(
            tibble(cv = c, 
                   marginal_r2_normal = MuMIn::r.squaredGLMM(lmer_norm)[1], 
                   conditional_r2_normal = MuMIn::r.squaredGLMM(lmer_norm)[2], 
                   marginal_r2_lognormal = MuMIn::r.squaredGLMM(lmer_lnorm)[1], 
                   conditional_r2_lognormal = MuMIn::r.squaredGLMM(lmer_lnorm)[2], 
                   marginal_r2_pref = MuMIn::r.squaredGLMM(lmer_pref)[1], 
                   conditional_r2_pref = MuMIn::r.squaredGLMM(lmer_pref)[2])
          )
        
        cat(c, "\n")
      }
      
      write_csv(out, paste0("output/tables/var_explained_bycv",  ifelse(inc_fished, "_incfished", "_unfished"), ".csv"))
      rm(c, out, estimated_prob, lmer_norm, lmer_lnorm, lmer_pref, joined_data, d1, d2)
    }
    
    
    p <- 
      paste0("output/tables/var_explained_bycv",  ifelse(inc_fished, "_incfished", "_unfished"), ".csv") %>% 
      read_csv(show_col_types = FALSE) %>% 
      pivot_longer(cols = contains("r2"), values_to = "r2") %>% 
      mutate(dist = str_extract(name, "(?<=r2_)[a-z]+"),
             r2_type = str_extract(name, "[a-z]+(?=_)")) %>% 
      filter(r2_type == "marginal") %>% 
      ggplot(aes(x = cv, 
                 y = r2, 
                 color = dist)) +
      geom_line(linewidth = 2, alpha = 0.8) +
      scale_color_manual(values = c("normal" = rgb(181, 144, 19, maxColorValue=255),
                                    "lognormal" = rgb(29, 84, 128, maxColorValue=255), 
                                    "pref" = "pink"),
                         labels = c("normal" = "Normal",
                                    "lognormal" = "Lognormal", 
                                    "pref" = "Preferred")) +
      guides(color = guide_legend(override.aes = list(alpha = 1) ) ) +
      scale_y_continuous(label = label_percent(), limits = c(0,0.8)) +
      labs(x = "Assumed Coefficient of Variation", 
           y = "Variance explained") +
      theme_cowplot(15) +
      theme(legend.position = c(0.95,0.95), 
            legend.justification = c(1,1),
            legend.title = element_blank(), 
            plot.background = element_rect(color = "black")) 
    
    all_median_cov <- 
      plotdata_gridcell %>% 
      filter(!lowmean) %>% 
      {if(inc_fished) . else filter(., !fished)} %>%
      pull(cov_pref) %>% 
      median() %>% 
      round(1)
    
    estimated_prob <- 
      meansizes_gridcell %>%  
      mutate(mu = mean_size, 
             sd = mu*all_median_cov, 
             sdlog = sqrt(log((all_median_cov^2)+1)), 
             meanlog = log(mean_size) - ((sdlog^2)/2)) %>% 
      right_join(obsdata_rls_gridcell %>% {if(inc_fished) . else filter(., !fished)}) %>% 
      mutate(p_norm = pnorm(size_max, mean = mu, sd = sd) -  pnorm(size_min, mean = mu, sd = sd),
             plnorm_upper = plnorm(size_max, meanlog = meanlog, sdlog = sdlog), 
             plnorm_lower = plnorm(size_min, meanlog = meanlog, sdlog = sdlog),
             p_lnorm = plnorm(size_max, meanlog = meanlog, sdlog = sdlog) - plnorm(size_min, meanlog = meanlog, sdlog = sdlog)) %>% 
      select(population, species,
             size_class, 
             p, p_norm, p_lnorm)
    
    lmer_norm <- lmerTest::lmer(p ~ p_norm + (1|species), data = estimated_prob) 
    lmer_lnorm <-  lmerTest::lmer(p ~ p_lnorm + (1|species), data = estimated_prob) 
    
    p_obs_vs_exp <-
      estimated_prob %>% 
      mutate(lmer_norm = predict(lmer_norm),
             lmer_lnorm = predict(lmer_lnorm)) %>%
      pivot_longer(cols = contains("p_"), 
                   names_to = "dist", 
                   values_to = "p_est") %>% 
      ggplot(aes(x = p_est, 
                 y = p, 
                 col = dist), pch = 21) +
      geom_point(alpha = 0.1) +
      geom_abline(slope = 1, lty = 2) +
      labs(y = "Observed probability in size bin", 
           x = "Predicted probabiliy in size bin") +
      scale_x_continuous(label = label_percent()) +
      scale_y_continuous(label = label_percent()) +
      scale_color_manual(values = c("p_norm" = rgb(181, 144, 19, maxColorValue=255),
                                    "p_lnorm" = rgb(29, 84, 128, maxColorValue=255)), 
                         labels = c("p_norm" = "Normal",
                                    "p_lnorm" = "Lognormal")) +
      guides(color = guide_legend(override.aes = list(alpha = 1) ) ) +
      theme_cowplot(20) +
      theme(legend.position = c(0.05,0.95), 
            legend.justification = c(0,1),
            legend.title = element_blank())
    
    
    p2 <- 
      p_obs_vs_exp + inset_element(
        p, 
        left =  0.6, right = 0.995, 
        bottom =  0.05, top = 0.495)
    
    ggsave(filename = paste0("manuscript/ms_figures/variation_explained", {if(inc_fished) "_incfished" else "_unfished"}, ".png"),
           plot = p2,
           height = 25,
           width = 35,
           units = "cm")
    
    ggsave(filename = "fig3_main.png",
           plot = p_obs_vs_exp,
           height = 25,
           width = 35,
           units = "cm")
    
    ggsave(filename = "fig3_inset.png",
           plot = p,
           height = 25,
           width = 35,
           units = "cm")
  }
}

```

# Supplementary material 

## Intraspecies CV variation

```{r}

if(!file.exists("manuscript/ms_figures/supplementary/intraspecies_cv_variation.png") | rerun_msfigures){
  
  species_highpops <- 
    plotdata_gridcell %>% 
    filter(!lowmean, 
           !bimodal) %>% 
    count(species, data) %>% 
    arrange(desc(n)) %>% 
    head(20) %>% 
    pull(species) 
  
  
  p <-
    plotdata_gridcell %>% 
    filter(!lowmean) %>% 
    filter(data == "rls") %>% 
    filter(species %in% species_highpops) %>% 
    left_join(meansizes_species %>% 
                mutate(species = str_extract(population, ".*(?=__)")) %>% 
                select(species, data, species_mean_size = mean_size)) %>% 
    ggplot(aes(x = species_mean_size, 
               col = fct_reorder(species, species_mean_size),
               y = cov_pref)) +
    geom_point(pch = 21) +
    scale_x_continuous(label = label_number(suffix = "cm")) +
    theme_cowplot() +
    theme(legend.title = element_blank(), 
          legend.text = element_text(size = 12)) +
    labs(x = "Species mean size", 
         y = "Coefficient of Variation") 
  
  ggsave(filename = "manuscript/ms_figures/supplementary/intraspecies_cv_variation.png",
         plot = p,
         height = 15,
         width = 15*1.618,
         units = "cm")
  rm(p, species_highpops)
}

```

## Empirical distributions with high CV values

```{r}

if(!file.exists(paste0("manuscript/ms_figures/supplementary/highcov_SSDs.png")) | rerun_msfigures){
  
  current_plotdata <- 
    plotdata_gridcell %>% 
    filter(!bimodal, 
           !lowmean)
  
  high_cov <- 
    current_plotdata %>% 
    filter(cov_pref > quantile(current_plotdata$cov_pref, 0.99)) %>% 
    pull(population)
  
  s_highcov_ssd <- 
    get(paste0("obsdata_rls_", "gridcell")) %>% 
    filter(population %in% high_cov) %>% 
    mutate(lat = str_extract(population, "(?<=__).\\d+") %>% as.numeric(), 
           lon = str_extract(population, "(?<=\\d_).\\d+") %>% as.numeric(),
           population_name = paste0(species, " \n (", lat, "°, ", lon, "°)")) %>% 
    ggplot() +
    aes(
      x = size_class, 
      y = n
    ) +
    geom_path() +
    geom_point() +
    facet_wrap(~population_name, scales = "free") +
    theme_cowplot(10) +
    labs(
      x = "Body size (cm)", 
      y = "Total abundance"
    )
  
  ggsave(filename = paste0("manuscript/ms_figures/supplementary/highcov_SSDs.png"),
         plot = s_highcov_ssd,
         height = 20,
         width = 32,
         units = "cm")
  
  rm(high_cov, s_highcov_ssd)
  
}

```

## Distribution preference with meansize

Distribution preference as a function of mean size. Larger species are more likely to be normally distributed. Reef Life Survey data only

```{r}

if(!file.exists(paste0("manuscript/ms_figures/supplementary/preference_meansize.png")) | rerun_msfigures){
  
  current_plotdata <- 
    plotdata_gridcell %>% 
    filter(!bimodal, 
           !lowmean)
  
  logit_mod <-
    current_plotdata %>% 
    mutate(normal_better = as.numeric(normal_better)) %>% 
    glm(normal_better ~ mean_size, data = ., family = "binomial")
  
  logit_plot <- 
    current_plotdata %>% 
    ggplot(aes(
      x = mean_size,
      y = normal_better %>% as.numeric)) +
    geom_point(alpha = 0.6, pch = 21, size = 3) +
    geom_smooth(method = "glm",
                method.args = list(family = "binomial"),
                col = "darkblue", fill = "darkblue") +
    # geom_line(aes(y = predict(logit_mod, type = "response"))) +
    scale_x_continuous(label = label_number(suffix = "cm")) +
    # scale_x_log10(label = label_number(suffix = "cm")) +
    theme_cowplot(20) +
    labs(
      x = "Mean size", 
      y = "Normal preferred"
    )
  
  ggsave(filename = paste0("manuscript/ms_figures/supplementary/preference_meansize.png"),
         plot = logit_plot,
         height = 25,
         width = 35,
         units = "cm")
  
}

```

## Does binning influence distribution preference?

```{r}

if(!file.exists(paste0("manuscript/ms_figures/supplementary/binning_influence_preference.png")) | rerun_msfigures){
  
  mod_out_filename_sup <- function(population_level, modelname, output_type, binning){
    paste0("output/model_fits/supplementary/cbf_", 
           output_type, "_", 
           modelname, "_", 
           population_level, "_", 
           binning,
           ".csv")
  }
  
  for(pop in c("location", "species")){
    
    cbf_filtered_data <- 
      get(paste0("obsdata_cbf_", pop)) 
    
    cbf_filtered_data_binned <- 
      cbf_filtered_data %>% 
      mutate(size_class = rls_bin(size_class*10)) %>% 
      add_count(population, name = "population_n") %>% 
      count(population, population_n, size_class)%>% 
      left_join(., get_bintable(.$size_class), 
                by = join_by(size_class)) %>% 
      add_count(population, name = "nbin") %>% 
      filter(nbin > 3, population_n > 10)
    
    
    for(mod in c("normal", "lognormal")){
      
      if(!(file.exists(paste0("output/model_fits/supplementary/cbf_pars_", mod, "_", pop, "_binned.csv")) &
           file.exists(paste0("output/model_fits/supplementary/cbf_pars_", mod, "_", pop, "_cont.csv")))){
        
        cbf_model_pars <- tibble(population = character())
        cbf_model_convergence <- tibble(population = character())
        cbf_model_errors <- tibble(population = character())
        
        cbf_model_pars_binned <- tibble(population = character())
        cbf_model_convergence_binned <- tibble(population = character())
        cbf_model_errors_binned <- tibble(population = character())
        
        for(i in unique(cbf_filtered_data_binned$population)){
          
          cbf_current_data <-
            cbf_filtered_data %>% 
            filter(population == i) 
          
          cbf_current_data_binned <- 
            cbf_filtered_data_binned %>% 
            filter(population == i) 
          
          
          cont_stan_data <- 
            list(
              B = length(unique(cbf_current_data$size_class)),
              b_upr = cbf_current_data$size_max,
              b_lwr = cbf_current_data$size_min,
              n = cbf_current_data$n, 
              low_bound = 0.05
            )
          
          cont_fit <- 
            stan(file = paste0("input/stan_models/", mod, ".stan"),
                 data = cont_stan_data,
                 iter = 10000,
                 warmup = 5000,
                 chains = 3,
                 refresh = 5000,
                 cores = 1)
          
          
          if(!is.null(summary(cont_fit)$summary)){
            
            rhat <- 
              summary(cont_fit)$summary[,"Rhat"] %>% 
              as_tibble(rownames = "pars") %>% 
              mutate(population = unique(cbf_current_data$population)) %>% 
              rename(rhat = value)
            
            n_eff <- 
              summary(cont_fit)$summary[,"n_eff"] %>% 
              as_tibble(rownames = "pars") %>% 
              mutate(population = unique(cbf_current_data$population)) %>% 
              rename(n_eff = value)
            
            cbf_model_convergence <- 
              bind_rows(
                cbf_model_convergence,
                left_join(rhat, n_eff, 
                          by = join_by(pars, population)))
            
            current_cbf_model_pars <- 
              cont_fit %>% 
              as_draws_df() %>% 
              as_tibble() %>% 
              mutate(population = i)
            
            cbf_model_pars <- 
              bind_rows(
                cbf_model_pars,
                current_cbf_model_pars
              )
            
            cat(paste(i, "done."))
            
          } else  {
            
            cbf_model_errors <- 
              bind_rows(
                cbf_model_errors, 
                tibble(population = i)
              )
            
            
          }
          
          binned_stan_data <- 
            list(
              B = length(unique(cbf_current_data_binned$size_class)),
              b_upr = cbf_current_data_binned$size_max,
              b_lwr = cbf_current_data_binned$size_min,
              n = cbf_current_data_binned$n, 
              low_bound = 2.5
            )
          
          if(mod == "normal"){
            
            inits <-
              cbf_current_data_binned %>% 
              uncount(n) %>% 
              summarise(mu = mean(size_class), 
                        sigma = sd(size_class),
                        meanlog = mean(log(size_class)), 
                        sdlog = sd(log(size_class)))
            
            
            binned_fit <- 
              stan(file = paste0("input/stan_models/", mod, ".stan"),
                   data = binned_stan_data,
                   iter = 10000,
                   warmup = 5000,
                   chains = 3,
                   refresh = 5000,
                   cores = 1,
                   init = list(list(mu = inits$mu, sigma = inits$sigma), 
                               list(mu = inits$mu, sigma = inits$sigma), 
                               list(mu = inits$mu, sigma = inits$sigma)))
          } else {
            
            binned_fit <- 
              stan(file = paste0("input/stan_models/", mod, ".stan"),
                   data = binned_stan_data,
                   iter = 10000,
                   warmup = 5000,
                   chains = 3,
                   refresh = 5000,
                   cores = 1)
          }
          
          if(!is.null(summary(binned_fit)$summary)){
            
            rhat_binned <- 
              summary(binned_fit)$summary[,"Rhat"] %>% 
              as_tibble(rownames = "pars") %>% 
              mutate(population = unique(cbf_current_data_binned$population)) %>% 
              rename(rhat = value)
            
            n_eff_binned <- 
              summary(binned_fit)$summary[,"n_eff"] %>% 
              as_tibble(rownames = "pars") %>% 
              mutate(population = unique(cbf_current_data_binned$population)) %>% 
              rename(n_eff = value)
            
            cbf_model_convergence_binned <- 
              bind_rows(
                cbf_model_convergence_binned,
                left_join(rhat_binned, n_eff_binned, 
                          by = join_by(pars, population)))
            
            current_cbf_model_pars_binned <- 
              cont_fit %>% 
              as_draws_df() %>% 
              as_tibble() %>% 
              mutate(population = i)
            
            cbf_model_pars_binned <- 
              bind_rows(
                cbf_model_pars_binned,
                current_cbf_model_pars_binned
              )
            
            cat(paste(i, "done."))
            
          } else  {
            
            cbf_model_errors_binned <- 
              bind_rows(
                cbf_model_errors_binned, 
                tibble(population = i)
              )
            
            
          }
          
        }
        
        cbf_model_pars %>% write_csv(mod_out_filename_sup(pop, mod, "pars", "cont"))
        cbf_model_convergence %>% write_csv(mod_out_filename_sup(pop, mod, "convergence", "cont"))
        cbf_model_errors %>% write_csv(mod_out_filename_sup(pop, mod, "errors", "cont"))
        
        cbf_model_pars_binned %>% write_csv(mod_out_filename_sup(pop, mod, "pars", "binned"))
        cbf_model_convergence_binned %>% write_csv(mod_out_filename_sup(pop, mod, "convergence", "binned"))
        cbf_model_errors_binned %>% write_csv(mod_out_filename_sup(pop, mod, "errors", "binned"))
        
      } else {
        cat(paste("Already ran", mod, "at the", pop, "level (binned and continuous)\n"))
      }
    }
  }
  
  for(pop in c("location")){
    for(datatype in c("cont", "binned")){
      
      for(mod in c("normal", "lognormal")){
        
        if(mod == "normal"){
          
          paste0("output/model_fits/supplementary/cbf_pars_", mod, "_", pop, "_", datatype,".csv") %>% 
            read_csv(show_col_types = FALSE) %>% 
            summarise(mu = mean(mu), 
                      sigma = mean(sigma), 
                      lp_normal = median(lp__),
                      .by = population) %>% 
            mutate(type = datatype) %>% 
            assign(x = paste("cbf_modelfit", mod, pop, datatype, sep = "_"), value = ., envir = .GlobalEnv)
          
        } else if(mod == "lognormal"){
          
          paste0("output/model_fits/supplementary/cbf_pars_", mod, "_", pop, "_", datatype,".csv") %>% 
            read_csv(show_col_types = FALSE) %>% 
            summarise(meanlog = mean(meanlog), 
                      sdlog = mean(sdlog),
                      lp_lognormal = median(lp__),
                      .by = population) %>% 
            mutate(type = datatype) %>% 
            assign(x = paste("cbf_modelfit", mod, pop, datatype, sep = "_"), value = ., envir = .GlobalEnv)
        }
        
      }
    }
  }
  
  pdat <- 
    bind_rows(
      full_join(
        cbf_modelfit_normal_location_cont, 
        cbf_modelfit_lognormal_location_cont,
        by = join_by(population, type)
      ), 
      full_join(
        cbf_modelfit_normal_location_binned, 
        cbf_modelfit_lognormal_location_binned,
        by = join_by(population, type)
      )) %>% 
    mutate(ll_diff = lp_normal - lp_lognormal) %>% 
    mutate(normal_better = lp_normal>lp_lognormal) %>% 
    select(population, type, normal_better) %>% 
    left_join(meansizes_ecoregion %>% filter(data == "cbf"))     ###### WHY IS THIS NOT GRIDCELL LEVEL
  
  p <-
    pdat %>% 
    ggplot(aes(x = mean_size, y = as.numeric(normal_better))) +
    geom_point(alpha = 0.6, pch = 21, size = 3) +
    geom_smooth(method = "glm",
                method.args = list(family = "binomial"),
                col = "darkblue", 
                fill = "darkblue", 
                data = pdat) +
    theme_cowplot(20) +
    # theme(plot.background = element_rect(col ="red"))+
    labs(
      x = "Species mean size (cm)", 
      y = "Normal preferred"
    ) +
    facet_wrap(~type, 
               labeller = as_labeller(c(binned = "Binned data", cont = "Continuous data")))
  
  
  ggsave(filename = paste0("manuscript/ms_figures/supplementary/binning_influence_preference.png"),
         plot = p,
         height = 15,
         width = 32,
         units = "cm")
  
}

```

## CV vs Meansize model

```{r}



if(!file.exists("manuscript/ms_figures/supplementary/cv_meansize_modelled.png") | rerun_msfigures){
  mod_data <- 
    plotdata_gridcell %>% 
    filter(!lowmean,
           !bimodal)
  
  cv_mod <- lmerTest::lmer(log(cov_pref) ~ mean_size*data + (1|species), data = mod_data) 
  
  summary(cv_mod)
  m1_pred <- effects::effect(term = "mean_size", 
                             mod = cv_mod, 
                             xlevels = list(mean_size = seq(1, 100, 1))) %>% 
    as_tibble()
  
  p <- 
    mod_data %>% 
    ggplot() + 
    aes(x = mean_size) +
    geom_point(aes( y = cov_pref,
                    pch = data,
                    col = better_dist)) +
    geom_ribbon(aes(ymin = exp(lower), 
                    ymax = exp(upper)), 
                data = m1_pred, alpha = 0.5) +
    geom_line(aes(y = exp(fit)), 
              data = m1_pred) +
    scale_x_log10(label = label_number(suffix = "cm")) +
    scale_shape_manual(values = c("rls" = 21, "cbf" = 24), 
                       labels = c("rls" = "Reef Life Survey (binned)",
                                  "cbf" = "Cryptobenthic (continuous)")) +
    scale_color_manual(values = c("normal" = rgb(181, 144, 19, maxColorValue=255),
                                  "lognormal" = rgb(29, 84, 128, maxColorValue=255)),
                       labels = c("normal" = "Normal preferred",
                                  "lognormal" = "Lognormal preferred")) +
    labs(x = "Log mean size", 
         y = "Coefficient of variation") +
    theme_cowplot(20) +
    theme(legend.position = "bottom", legend.title = element_blank())
  
  ggsave(filename = "manuscript/ms_figures/supplementary/cv_meansize_modelled.png",
         plot = p,
         height = 15,
         width = 32,
         units = "cm")
  rm(p)
}

```

## Population sizes

```{r}

get_npops <- Vectorize(function(src, pop, has_cv, rm_bimodal, rm_lowmean){
  
  temp_pop <- ifelse(pop == "location", "gridcell", pop)
  cbf_pop  <- ifelse(pop %in% c("ecoregion", "gridcell"), "location", pop)
  
  if(src == "all"){
    
    {if(!has_cv) bind_rows(get(paste("obsdata", "rls", pop, sep = "_")), 
                           get(paste("obsdata", "cbf", cbf_pop, sep = "_"))) else get(paste("plotdata", pop, sep = "_"))} %>% 
      {if(rm_bimodal) filter(., !bimodal) else .} %>% 
      {if(rm_lowmean) filter(., !lowmean) else .} %>% 
      pull(population) %>% 
      unique() %>% 
      length()
  } else {
    
    {if(!has_cv) get(paste("obsdata", src, pop, sep = "_")) else get(paste("plotdata", temp_pop, sep = "_")) %>% filter(data == src)} %>% 
      {if(rm_bimodal) filter(., !bimodal) else .} %>% 
      {if(rm_lowmean) filter(., !lowmean) else .} %>% 
      pull(population) %>% 
      unique() %>% 
      length()
    
  }
})


if(!file.exists("output/tables/population_sizes.csv") | rerun_tables){
  tibble(src = c("rls", "all")) %>%
    expand_grid(pop = c("species", "ecoregion", "gridcell")) %>% 
    bind_rows(tibble(src = "cbf", 
                     pop = c("species", "location"))) %>% 
    expand_grid(has_cv = c(TRUE, FALSE), 
                rm_bimodal = c(TRUE, FALSE),
                rm_lowmean = c(TRUE, FALSE)) %>% 
    filter(!(!has_cv & rm_bimodal)) %>% 
    filter(!(!has_cv & rm_lowmean)) %>% 
    mutate(popsize = get_npops(src, pop, has_cv, rm_bimodal, rm_lowmean)) %>% 
    write_csv("output/tables/population_sizes.csv")
}

```

## CV estimates

```{r}


get_cv <- Vectorize(function(src, pop, rm_bimodal, rm_fished, mod, quant){
  
  pop <- ifelse(pop == "location", "gridcell", pop)
  
  get(paste0("plotdata_", pop)) %>% 
    filter(!lowmean) %>% 
    {if(src != "all") filter(., data == src) else .} %>% 
    {if(rm_bimodal) filter(., !bimodal) else .} %>% 
    {if(rm_fished) filter(., !fished) else .} %>% 
    pull(sym(paste0("cov_", mod))) %>% 
    quantile(quant)
  
})

if(!file.exists("output/tables/cv_quantiles.csv") | rerun_tables){
  
  tibble(src = c("rls", "all")) %>%
    expand_grid(pop = c("species", "ecoregion", "gridcell")) %>% 
    bind_rows(tibble(src = "cbf", 
                     pop = c("species", "location"))) %>% 
    expand_grid(rm_bimodal = c(TRUE, FALSE), 
                rm_fished = c(TRUE, FALSE), 
                mod = c("normal", "lognormal", "pref"), 
                quant = c(0.025, 0.05, 0.1, 0.5, 0.9, 0.95, 0.975)) %>% 
    mutate(cv = get_cv(src, pop, rm_bimodal, rm_fished, mod, quant)) %>% 
    pivot_wider(values_from = cv, 
                names_from = quant) %>% 
    write_csv("output/tables/cv_quantiles.csv")
}


# all populations
wilcox.test(
  plotdata_gridcell %>% filter(better_dist == "normal") %>% pull(cov_pref), 
  plotdata_gridcell %>% filter(better_dist == "lognormal") %>% pull(cov_pref)
)

# unimodal populations
wilcox.test(
  get(paste0("plotdata_", "gridcell"))  %>% 
    filter(!lowmean,
           !bimodal,
           better_dist == "normal") %>% 
    pull(cov_pref), 
  get(paste0("plotdata_", "gridcell"))  %>% 
    filter(!lowmean,
           !bimodal,
           better_dist == "lognormal") %>% 
    pull(cov_pref))

wilcox.test(normal_cov, conf.int = TRUE, conf.level = 0.95)
wilcox.test(lognormal_cov, conf.int = TRUE, conf.level = 0.95)

# species-level
wilcox.test(normal_cov_species, conf.int = TRUE, conf.level = 0.95)
wilcox.test(lognormal_cov_species, conf.int = TRUE, conf.level = 0.95)

wilcox.test(normal_cov, lognormal_cov)


```

## Convergence issues

```{r}

# how many RLS had convergence issues?
not_run <- 
  nonconverge_pops("rls", "lognormal", "gridcell") %>% 
  c(nonconverge_pops("rls", "normal", "gridcell")) %>% 
  unique()

nonconverge_pops("rls", "lognormal", "gridcell")[nonconverge_pops("rls", "lognormal", "gridcell") %!in% nonconverge_pops("rls", "normal", "gridcell")] %>% length()
nonconverge_pops("rls", "normal", "gridcell")[nonconverge_pops("rls", "normal", "gridcell") %!in% nonconverge_pops("rls", "lognormal", "gridcell")] %>% length()

```

## Species common to both CBF and RLS

```{r}

if(!file.exists("manuscript/ms_figures/supplementary/cbf_rls_common_sdd.png")| rerun_msfigures){
  rls_species <- get(paste0("obsdata_rls_", "species")) %>% pull(species)
  cbf_species <- get(paste0("obsdata_cbf_", "species")) %>% pull(species)
  
  # species that exist in both RLS and CBF data
  common_spp_species <- rls_species[rls_species %in% cbf_species] %>% unique()
  
  p <- 
    get(paste0("obsdata_rls_", "species")) %>%  
    filter(species %in% common_spp) %>% 
    ggplot() +
    geom_point(aes(x = size_class, y = p)) +
    geom_path(aes(x = size_class, y = p)) +
    facet_wrap(~species, scales = "free") +
    geom_density(aes(x = tl_cm), data = 
                   get(paste0("obsdata_cbf_", "species")) %>%  
                   filter(species %in% common_spp), col = "red") 
  
  ggsave(filename = "manuscript/ms_figures/supplementary/cbf_rls_common_sdd.png",
         plot = p,
         height = 15,
         width = 32,
         units = "cm")
  
}



```


## Numerical calculation of the parameters

```{r}


if(!file.exists("manuscript/ms_figures/supplementary/parameter_regression_numerical.png")| rerun_msfigures){
  
  for(pop in c("species", "ecoregion", "gridcell")){
    
    cbf_pop <- ifelse(pop %in% c("ecoregion", "gridcell"), "location", pop)
    
    q_cov <- function(quant) quantile(plotdata_current$cov, quant)
    
    plot_data2_rls <- 
      obsdata_filename("rls", pop) %>%
      read_csv(show_col_types = FALSE) %>% 
      select(population, size_class, n) %>% 
      uncount(n) %>% 
      summarise(
        mean = mean(size_class), 
        sd = sd(size_class), 
        logmean = mean(log(size_class)), 
        logsd = sd(log(size_class)), 
        .by = population
      ) %>% 
      mutate(cov1 = sd/mean, 
             cov2 = sqrt(exp(logsd)-1))  %>% 
      mutate(data = "rls")
    
    plot_data2_cbf <- 
      obsdata_filename("cbf", cbf_pop) %>%
      read_csv(show_col_types = FALSE) %>% 
      select(population, size_class, n) %>% 
      uncount(n) %>% 
      summarise(
        mean = mean(size_class), 
        sd = sd(size_class), 
        logmean = mean(log(size_class)), 
        logsd = sd(log(size_class)), 
        .by = population
      ) %>% 
      mutate(cov1 = sd/mean, 
             cov2 = sqrt(exp(logsd)-1))  %>% 
      mutate(data = "cbf")
    
    bind_rows(plot_data2_rls, 
              plot_data2_cbf) %>% 
      assign(x = paste0("plotdata2_", pop), 
             value = ., 
             envir = .GlobalEnv)
    
    # bimodal_pops <- 
    #   paste0("input/data_cleaning/bimodal_", pop, ".csv") %>% 
    #   read_csv(show_col_types = FALSE) %>% 
    #   pull(population)
    
    plotdata_current <- 
      get(paste0("plotdata2_", pop)) %>% 
      left_join(get(paste0("meansizes_", pop))) #%>% 
    # filter(!population %in% bimodal_pops)
    
    q_cov <- function(quant) quantile(plotdata_current$cov, quant)
    
    p1 <- 
      plotdata_current %>% 
      ggplot() + 
      aes(
        x = mean_size, 
        y = cov1, 
        col = data
      ) +
      annotate(geom = "rect",
               xmin = min(plotdata_current$mean_size), 
               xmax = max(plotdata_current$mean_size), 
               ymin = q_cov(0.975),
               ymax = q_cov(0.025), 
               fill = "grey90", 
               col = "transparent") +
      annotate(geom = "rect",
               xmin = min(plotdata_current$mean_size), 
               xmax = max(plotdata_current$mean_size), 
               ymin = q_cov(0.05),
               ymax = q_cov(0.95), 
               fill = "grey70", 
               col = "transparent") +
      annotate(geom = "rect",
               xmin = min(plotdata_current$mean_size), 
               xmax = max(plotdata_current$mean_size), 
               ymin = q_cov(0.1),
               ymax = q_cov(0.9), 
               fill = "grey50", 
               col = "transparent") +
      annotate(geom = "text", 
               x = 100, y = q_cov(0.9) - ((q_cov(0.9) - q_cov(0.1))/2),
               label = "80%") +
      annotate(geom = "text", 
               x = 100, y = q_cov(0.95) - ((q_cov(0.95) - q_cov(0.9))/2), 
               label = "90%") +
      annotate(geom = "text", 
               x = 100, y = q_cov(0.975) - ((q_cov(0.975) - q_cov(0.95))/2), 
               label = "95%") +
      geom_point(alpha = 0.3) +
      scale_x_continuous(trans = "log10", labels = label_number(suffix="cm"), 
                         limits = range(plotdata_current$mean_size)) +
      labs(x = "Log mean size", 
           y = "Coefficient of variation") +
      theme_cowplot(20) +
      theme(legend.position = "none")
    
    assign(x = paste0("p1_", pop), value = p1, envir = .GlobalEnv)
    
    p2 <- 
      plotdata_current %>% 
      ggplot() +
      aes(
        x = cov1, 
        col = data
      ) +
      geom_density(alpha = 0.3) +
      coord_flip() +
      theme_void(20) +
      theme(legend.position = "none") 
    
    
    assign(x = paste0("p2_", pop), value = p2, envir = .GlobalEnv)
    
    ggsave(filename = paste0("output/figs/param_regression_", pop, "_numerical.png"),
           plot = p1 + p2 + plot_layout(widths = c(6,1)),
           height = 15,
           width = 40,
           units = "cm")
    
    rm(p1, p2)
    
  }
  
  legend_only <- get_legend(
    p1_gridcell + theme(legend.position = "bottom",
                        legend.justification = c(0.5,0.5),
                        legend.background = element_rect(color = "black"),
                        legend.margin=margin(10,10,10,10),
                        legend.title = element_blank()))
  
  plot_ylim <- max(layer_scales(p1_gridcell)$y$range$range, layer_scales(p1_species)$y$range$range)
  
  fig1 <-
    p1_gridcell + annotate("text", x = 10, y = 1.2, label = "Population-level", size = 12) + ylim(0, plot_ylim) +
    p2_gridcell + xlim(0, plot_ylim) +
    p1_species + annotate("text", x = 10, y = 1.2, label = "Species-level", size = 12) + ylim(0, plot_ylim) + theme(axis.title.y = element_blank()) +
    p2_species + xlim(0, plot_ylim) + 
    ggpubr::as_ggplot(legend_only) +
    plot_layout(design = "
  AAAAAABCCCCCCD
  AAAAAABCCCCCCD
  AAAAAABCCCCCCD
  AAAAAABCCCCCCD
  AAAAAABCCCCCCD
  ####EEEEEE####")
  
  ggsave(filename = "manuscript/ms_figures/supplementary/parameter_regression_numerical.png",
         plot = fig1,
         height = 15,
         width = 40,
         units = "cm")
  
  
  
}

```

## Predicted distribution 

```{r}

rls_bin_breaks <- 
  c(2.5, 5.0, 7.5,  10.0, 12.5, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0, 
    50.0, 62.5, 75.0, 87.5, 100.0, 112.5, 125.0, 137.5, 150.0, 
    162.5, 175.0, 187.5, 200.0, 250.0, 300.0, 350.0, 400.0)

predict_size <- function(meansize){
  
  tibble(size_class = c(0, rls_bin_breaks, 500)) %>% 
    mutate(
      size_indx  = 0:(length(size_class)-1),
      size_min = (size_class + lag(size_class))/2,
      size_max = lead(size_min)
    ) %>% 
    filter(size_class %in% c(rls_bin_breaks, 500)) %>% 
    mutate(Normal = pnorm(size_max, meansize, meansize*0.3) - pnorm(size_min, meansize, meansize*0.3), 
           Lognormal = plnorm(size_max, log(meansize)-0.043, 0.291) - plnorm(size_min, log(meansize)-0.043, 0.291)) %>% 
    pivot_longer(cols = contains("ormal"), 
                 names_to = "dist", 
                 values_to = "p") %>% 
    filter(p > 0.001) 
}


pred_vs_obs <- function(pop_indx, inc_obs = TRUE){
  myppop <- 
    obsdata_rls_gridcell %>% 
    filter(population_indx == pop_indx)
  
  mypop_meansize <- 
    myppop %>% 
    uncount(n) %>% 
    pull(size_class) %>% 
    mean()
  
  print(paste("Mean size =", mypop_meansize %>% round(1), "cm") )
  
  predict_size(mypop_meansize) %>% 
    bind_rows(myppop %>% 
                select(population, size_class, size_min, size_max, p) %>% 
                mutate(dist = "Observed")) %>% 
    {if(!inc_obs) filter(., dist != "Observed") else .} %>% 
    ggplot(aes(x = size_class, y = p, color = dist)) +
    geom_path(linewidth = 2) +
    geom_point(size = 4) +
    theme_cowplot() +
    labs(x = "Body size (cm)", y = "Probability") +
    theme(legend.position = c(1,1), 
          legend.justification = c(1.1,1.1), 
          legend.title = element_blank()) +
    scale_color_manual(values = c("Lognormal" = rgb(29, 84, 128, maxColorValue=255), 
                                  "Normal" = rgb(181, 144, 19, maxColorValue=255), 
                                  "Observed" = "black"))
}

pred_vs_obs(4, FALSE)
pred_vs_obs(4, TRUE)


```

```{r}

presdat1 <- 
  obsdata_rls_gridcell %>% 
  filter(population_indx < 10) 

presdat2 <- 
  plotdata_gridcell %>% 
  filter(population %in% presdat1$population) %>% 
  right_join(presdat1 %>% select(population, size_class, size_min, size_max)) %>% 
  mutate(p_norm = pnorm(size_max, mu, sigma) - pnorm(size_min, mu, sigma), 
         p_lnorm = plnorm(size_max, meanlog, sdlog) - plnorm(size_min, meanlog, sdlog)) %>% 
  select(population, size_class, p_norm, p_lnorm) %>% 
  pivot_longer(cols = contains("p_"))


presdat1 %>% 
  ggplot() +
  geom_point(aes(x = size_class, 
                 y = p)) +
  geom_path(aes(x = size_class, 
                y = p)) +
  geom_path(aes(y = value, x = size_class, col = name), data = presdat2, linewidth = 1.5, alpha = 0.8) +
  scale_color_manual(values = c("p_lnorm" = rgb(29, 84, 128, maxColorValue=255), 
                                "p_norm" = rgb(181, 144, 19, maxColorValue=255)), 
                     label = c("p_lnorm" = "Lognormal", 
                               "p_norm" = "Normal")) +
  facet_wrap(~population, scales = "free") +
  theme_cowplot() +
  labs(x = "Body size (cm)", 
       y = "Probability") +
  theme(legend.title = element_blank())

```

## Number of transect per gridcell

```{r}

n_transects_gridcell <- 
  obsdata_rls_gridcell %>% 
  select(population, n_transects) %>% 
  distinct()

plotdata_gridcell %>% 
  left_join(n_transects_gridcell, by = join_by(population)) %>% 
  filter(!lowmean) %>% 
  ggplot(aes(x = n_transects %>% log(),
             y = cov_pref)) +
  geom_point(alpha = 0.1) +
  geom_smooth()

plotdata_gridcell %>% 
  left_join(n_transects_gridcell, by = join_by(population)) %>% 
  filter(!lowmean) %>% 
  lm(cov_pref ~ (n_transects), data = .) %>% 
  summary()

# the more transects at a given gridcell the larger the CV, but extremely minor, 0.0001 increase in CV per transect/survey

plotdata_gridcell %>% 
  left_join(n_transects_gridcell, by = join_by(population)) %>% 
  filter(!lowmean) %>% 
  ggplot(aes(x = n_transects,
             y = normal_better %>% as.numeric())) +
  geom_point(alpha = 0.1) +
  geom_smooth()


```

```{r}

predat3 <- 
obsdata_cbf_location %>% 
  filter(cumsum(!duplicated(population)) %in% 3:11) %>% 
  ggplot(aes(x = size_class, y = n)) +
  geom_point() +
  geom_path() +
  facet_wrap(~population, scales = "free", ncol = 3) +
  theme_cowplot() +
  labs(y = "Count", 
       x = "Body size (cm)")

predat4 <- 
  obsdata_rls_gridcell %>% 
  filter(cumsum(!duplicated(population)) %in% 3:11) %>% 
  ggplot(aes(x = size_class, y = n)) +
  geom_point() +
  geom_path() +
  facet_wrap(~population, scales = "free", ncol = 3) +
  theme_cowplot() +
  labs(y = "Count", 
       x = "Body size (cm)")

ggsave("cbf_dists.png", predat3, width = 10, height = 10)
ggsave("rls_dists.png", predat4, width = 10, height = 10)
  
```

